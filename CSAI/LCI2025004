//SPDX-License-Identifier:MIT
pragma solidity ^0.8.30;
contract Voting {
    struct Candidate {
        string name;
        uint256 votecount;
 }
    Candidate[] public candidates;
    address[] public voters;
    address public owner;
    bool public votingclosed=false;
    constructor(){
        owner =msg.sender;
 }

    modifier onlyOwner(){
        require(msg.sender == owner,"Only owner can add candidates");
        _;
    }

    modifier votingopen {
        require(!votingclosed,"Voting is closed");
        _;
    }
    
    function addCandidate(string memory _name) public onlyOwner {
        candidates.push(Candidate(_name,0));


    }

    function hasAlreadyVoted(address _voter) internal view returns(bool){
        for (uint i=0; i< voters.length;i++) {
            if (voters[i]== _voter){
                return true;
            }
        }
return false;
    
    } 
    function vote(uint256 candidateIndex) public  votingopen {
        require(candidateIndex < candidates.length, "Invalid candidate index");
        require(!hasAlreadyVoted(msg.sender),"You already voted");
        voters.push(msg.sender);
        candidates[candidateIndex].votecount++; 
    }
    function closevoting() public onlyOwner {
        votingclosed = true;
    }
    
    function getwinner() public view returns (string memory,uint256){
        require(votingclosed, "Voting not closed yet");
        uint256 highest=0;
        uint256 winnerindex=0;
   

    for(uint i=0;i<candidates.length;i++) {
        if  (candidates[i].votecount >highest){
            highest =candidates[i].votecount;
            winnerindex= i;
        }
    }
    return (candidates[winnerindex].name,candidates[winnerindex].votecount);
    }
    function getTotalCandidates() public view returns (uint256){
        return candidates.length;
    }
    function getCandidate(uint256 index) public view returns (string memory,uint256){
        Candidate memory c= candidates[index];
        return (c.name,c.votecount);

    }
  
    }

